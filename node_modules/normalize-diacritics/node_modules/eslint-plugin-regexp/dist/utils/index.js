"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getQuantifierOffsets = exports.fixerApplyEscape = exports.availableRegexpLocation = exports.getRegexpLocation = exports.getRegexpRange = exports.defineRegexpVisitor = exports.createRule = exports.FLAG_UNICODE = exports.FLAG_STICKY = exports.FLAG_MULTILINE = exports.FLAG_IGNORECASE = exports.FLAG_DOTALL = exports.FLAG_GLOBAL = void 0;
const regexpp_1 = require("regexpp");
const eslint_utils_1 = require("eslint-utils");
__exportStar(require("./unicode"), exports);
exports.FLAG_GLOBAL = "g";
exports.FLAG_DOTALL = "s";
exports.FLAG_IGNORECASE = "i";
exports.FLAG_MULTILINE = "m";
exports.FLAG_STICKY = "y";
exports.FLAG_UNICODE = "u";
function createRule(ruleName, rule) {
    return {
        meta: Object.assign(Object.assign({}, rule.meta), { docs: Object.assign(Object.assign({}, rule.meta.docs), { url: `https://ota-meshi.github.io/eslint-plugin-regexp/rules/${ruleName}.html`, ruleId: `regexp/${ruleName}`, ruleName }) }),
        create: rule.create,
    };
}
exports.createRule = createRule;
function defineRegexpVisitor(context, rule) {
    const parser = new regexpp_1.RegExpParser();
    function verify(node, pattern, flags, createVisitor) {
        let patternNode;
        try {
            patternNode = parser.parsePattern(pattern, 0, pattern.length, flags.includes("u"));
        }
        catch (_a) {
            return;
        }
        const visitor = createVisitor(node, pattern, flags);
        if (Object.keys(visitor).length === 0) {
            return;
        }
        regexpp_1.visitRegExpAST(patternNode, visitor);
    }
    const createLiteralVisitor = "createVisitor" in rule
        ? rule.createVisitor
        : "createLiteralVisitor" in rule
            ? rule.createLiteralVisitor
            : null;
    const createSourceVisitor = "createVisitor" in rule
        ? rule.createVisitor
        : "createSourceVisitor" in rule
            ? rule.createSourceVisitor
            : null;
    return Object.assign(Object.assign({}, (createLiteralVisitor
        ? {
            "Literal[regex]"(node) {
                verify(node, node.regex.pattern, node.regex.flags, createLiteralVisitor);
            },
        }
        : null)), (createSourceVisitor
        ? {
            Program() {
                const scope = context.getScope();
                const tracker = new eslint_utils_1.ReferenceTracker(scope);
                for (const { node } of tracker.iterateGlobalReferences({
                    RegExp: { [eslint_utils_1.CALL]: true, [eslint_utils_1.CONSTRUCT]: true },
                })) {
                    const newOrCall = node;
                    const [patternNode, flagsNode] = newOrCall.arguments;
                    if (!patternNode ||
                        patternNode.type === "SpreadElement") {
                        continue;
                    }
                    const pattern = eslint_utils_1.getStringIfConstant(patternNode, scope);
                    const flags = eslint_utils_1.getStringIfConstant(flagsNode, scope);
                    if (typeof pattern === "string") {
                        let verifyPatternNode = patternNode;
                        if (patternNode.type === "Identifier") {
                            const variable = eslint_utils_1.findVariable(context.getScope(), patternNode);
                            if (variable && variable.defs.length === 1) {
                                const def = variable.defs[0];
                                if (def.type === "Variable" &&
                                    def.parent.kind === "const" &&
                                    def.node.init &&
                                    def.node.init.type === "Literal") {
                                    verifyPatternNode = def.node.init;
                                }
                            }
                        }
                        verify(verifyPatternNode, pattern, flags || "", createSourceVisitor);
                    }
                }
            },
        }
        : null));
}
exports.defineRegexpVisitor = defineRegexpVisitor;
function getRegexpRange(sourceCode, node, regexpNode) {
    if (!availableRegexpLocation(sourceCode, node)) {
        return null;
    }
    const nodeStart = node.range[0] + 1;
    return [nodeStart + regexpNode.start, nodeStart + regexpNode.end];
}
exports.getRegexpRange = getRegexpRange;
function getRegexpLocation(sourceCode, node, regexpNode, offsets) {
    const range = getRegexpRange(sourceCode, node, regexpNode);
    if (range == null) {
        return node.loc;
    }
    if (offsets) {
        return {
            start: sourceCode.getLocFromIndex(range[0] + offsets[0]),
            end: sourceCode.getLocFromIndex(range[0] + offsets[1]),
        };
    }
    return {
        start: sourceCode.getLocFromIndex(range[0]),
        end: sourceCode.getLocFromIndex(range[1]),
    };
}
exports.getRegexpLocation = getRegexpLocation;
function availableRegexpLocation(sourceCode, node) {
    if (node.type !== "Literal") {
        return false;
    }
    if (!node.regex) {
        if (typeof node.value !== "string") {
            return false;
        }
        if (sourceCode.text.slice(node.range[0] + 1, node.range[1] - 1) !==
            node.value) {
            return false;
        }
    }
    return true;
}
exports.availableRegexpLocation = availableRegexpLocation;
function fixerApplyEscape(text, node) {
    if (node.type !== "Literal") {
        throw new Error(`illegal node type:${node.type}`);
    }
    if (!node.regex) {
        return text.replace(/\\/gu, "\\\\");
    }
    return text;
}
exports.fixerApplyEscape = fixerApplyEscape;
function getQuantifierOffsets(qNode) {
    const startOffset = qNode.element.end - qNode.start;
    const endOffset = qNode.raw.length - (qNode.greedy ? 0 : 1);
    return [startOffset, endOffset];
}
exports.getQuantifierOffsets = getQuantifierOffsets;
