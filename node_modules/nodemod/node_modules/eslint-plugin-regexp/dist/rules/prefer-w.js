"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils");
function isSmallLetterCharacterClassRange(node) {
    return (node.type === "CharacterClassRange" &&
        node.min.value === utils_1.CP_SMALL_A &&
        node.max.value === utils_1.CP_SMALL_Z);
}
function isCapitalLetterCharacterClassRange(node) {
    return (node.type === "CharacterClassRange" &&
        node.min.value === utils_1.CP_CAPITAL_A &&
        node.max.value === utils_1.CP_CAPITAL_Z);
}
function isDigitCharacterClass(node) {
    return ((node.type === "CharacterClassRange" &&
        node.min.value === utils_1.CP_DIGIT_ZERO &&
        node.max.value === utils_1.CP_DIGIT_NINE) ||
        (node.type === "CharacterSet" && node.kind === "digit"));
}
function includesLowLineCharacterClass(node) {
    return node.type === "Character" && node.value === utils_1.CP_LOW_LINE;
}
exports.default = utils_1.createRule("prefer-w", {
    meta: {
        docs: {
            description: "enforce using `\\w`",
            recommended: true,
        },
        fixable: "code",
        schema: [],
        messages: {
            unexpected: 'Unexpected character set "{{expr}}". Use "{{instead}}" instead.',
        },
        type: "suggestion",
    },
    create(context) {
        const sourceCode = context.getSourceCode();
        function createVisitor(node, _pattern, flags) {
            return {
                onCharacterClassEnter(ccNode) {
                    const lowerAToZ = [];
                    const capitalAToZ = [];
                    const digit = [];
                    const lowLine = [];
                    for (const element of ccNode.elements) {
                        if (isSmallLetterCharacterClassRange(element)) {
                            lowerAToZ.push(element);
                            if (flags.includes(utils_1.FLAG_IGNORECASE)) {
                                capitalAToZ.push(element);
                            }
                        }
                        else if (isCapitalLetterCharacterClassRange(element)) {
                            capitalAToZ.push(element);
                            if (flags.includes(utils_1.FLAG_IGNORECASE)) {
                                lowerAToZ.push(element);
                            }
                        }
                        else if (isDigitCharacterClass(element)) {
                            digit.push(element);
                        }
                        else if (includesLowLineCharacterClass(element)) {
                            lowLine.push(element);
                        }
                    }
                    if (lowerAToZ.length &&
                        capitalAToZ.length &&
                        digit.length &&
                        lowLine.length) {
                        const unexpectedElements = [
                            ...new Set([
                                ...lowerAToZ,
                                ...capitalAToZ,
                                ...digit,
                                ...lowLine,
                            ]),
                        ].sort((a, b) => a.start - b.start);
                        if (ccNode.elements.length === unexpectedElements.length) {
                            const instead = ccNode.negate ? "\\W" : "\\w";
                            context.report({
                                node,
                                loc: utils_1.getRegexpLocation(sourceCode, node, ccNode),
                                messageId: "unexpected",
                                data: {
                                    expr: ccNode.raw,
                                    instead,
                                },
                                fix(fixer) {
                                    const range = utils_1.getRegexpRange(sourceCode, node, ccNode);
                                    if (range == null) {
                                        return null;
                                    }
                                    return fixer.replaceTextRange(range, utils_1.fixerApplyEscape(instead, node));
                                },
                            });
                        }
                        else {
                            context.report({
                                node,
                                loc: utils_1.getRegexpLocation(sourceCode, node, ccNode),
                                messageId: "unexpected",
                                data: {
                                    expr: `[${unexpectedElements
                                        .map((e) => e.raw)
                                        .join("")}]`,
                                    instead: "\\w",
                                },
                                *fix(fixer) {
                                    const range = utils_1.getRegexpRange(sourceCode, node, ccNode);
                                    if (range == null) {
                                        return;
                                    }
                                    yield fixer.replaceTextRange(utils_1.getRegexpRange(sourceCode, node, unexpectedElements.shift()), utils_1.fixerApplyEscape("\\w", node));
                                    for (const element of unexpectedElements) {
                                        yield fixer.removeRange(utils_1.getRegexpRange(sourceCode, node, element));
                                    }
                                },
                            });
                        }
                    }
                },
            };
        }
        return utils_1.defineRegexpVisitor(context, {
            createVisitor,
        });
    },
});
