"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils");
exports.default = utils_1.createRule("no-invisible-character", {
    meta: {
        docs: {
            description: "disallow invisible raw character",
            recommended: true,
        },
        fixable: "code",
        schema: [],
        messages: {
            unexpected: 'Unexpected invisible character. Use "{{instead}}" instead.',
        },
        type: "suggestion",
    },
    create(context) {
        const sourceCode = context.getSourceCode();
        function createLiteralVisitor(node) {
            return {
                onCharacterEnter(cNode) {
                    if (cNode.raw === " ") {
                        return;
                    }
                    if (cNode.raw.length === 1 && utils_1.isInvisible(cNode.value)) {
                        const instead = utils_1.invisibleEscape(String.fromCodePoint(cNode.value));
                        context.report({
                            node,
                            loc: utils_1.getRegexpLocation(sourceCode, node, cNode),
                            messageId: "unexpected",
                            data: {
                                instead,
                            },
                            fix(fixer) {
                                const range = utils_1.getRegexpRange(sourceCode, node, cNode);
                                return fixer.replaceTextRange(range, instead);
                            },
                        });
                    }
                },
            };
        }
        function verifyString(node) {
            const text = sourceCode.getText(node);
            let index = 0;
            for (const c of text) {
                const cp = c.codePointAt(0);
                if (utils_1.isInvisible(cp)) {
                    const instead = utils_1.invisibleEscape(cp);
                    const range = [
                        node.range[0] + index,
                        node.range[0] + index + c.length,
                    ];
                    context.report({
                        node,
                        loc: {
                            start: sourceCode.getLocFromIndex(range[0]),
                            end: sourceCode.getLocFromIndex(range[1]),
                        },
                        messageId: "unexpected",
                        data: {
                            instead,
                        },
                        fix(fixer) {
                            return fixer.replaceTextRange(range, instead);
                        },
                    });
                }
                index += c.length;
            }
        }
        return utils_1.defineRegexpVisitor(context, {
            createLiteralVisitor,
            createSourceVisitor(node) {
                if (node.type === "Literal") {
                    verifyString(node);
                }
                return {};
            },
        });
    },
});
