"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils");
const OPTION_SS1 = "[\\s\\S]";
const OPTION_SS2 = "[\\S\\s]";
const OPTION_CARET = "[^]";
const OPTION_DOTALL = "dotAll";
function getCharacterSetKey(node) {
    if (node.kind === "property") {
        return `\\p{${node.kind +
            (node.value == null ? node.key : `${node.key}=${node.value}`)}}`;
    }
    return node.kind;
}
exports.default = utils_1.createRule("match-any", {
    meta: {
        docs: {
            description: "enforce match any character style",
            recommended: true,
        },
        fixable: "code",
        schema: [
            {
                type: "object",
                properties: {
                    allows: {
                        type: "array",
                        items: {
                            type: "string",
                            enum: [
                                OPTION_SS1,
                                OPTION_SS2,
                                OPTION_CARET,
                                OPTION_DOTALL,
                            ],
                        },
                        uniqueItems: true,
                        minItems: 1,
                    },
                },
            },
        ],
        messages: {
            unexpected: 'Unexpected using "{{expr}}" to match any character.',
        },
        type: "suggestion",
    },
    create(context) {
        var _a, _b;
        const sourceCode = context.getSourceCode();
        const allowList = (_b = (_a = context.options[0]) === null || _a === void 0 ? void 0 : _a.allows) !== null && _b !== void 0 ? _b : [OPTION_SS1, OPTION_DOTALL];
        const allows = new Set(allowList);
        const prefer = (allowList[0] !== OPTION_DOTALL && allowList[0]) || null;
        function fix(fixer, node, regexpNode) {
            if (!prefer) {
                return null;
            }
            const range = utils_1.getRegexpRange(sourceCode, node, regexpNode);
            if (range == null) {
                return null;
            }
            if (regexpNode.type === "CharacterClass" &&
                prefer.startsWith("[") &&
                prefer.endsWith("]")) {
                return fixer.replaceTextRange([range[0] + 1, range[1] - 1], utils_1.fixerApplyEscape(prefer.slice(1, -1), node));
            }
            return fixer.replaceTextRange(range, utils_1.fixerApplyEscape(prefer, node));
        }
        function createVisitor(node, _pattern, flags) {
            let characterClassData = null;
            return {
                onCharacterSetEnter(csNode) {
                    if (csNode.kind === "any") {
                        if (flags.includes(utils_1.FLAG_DOTALL)) {
                            if (!allows.has(OPTION_DOTALL)) {
                                context.report({
                                    node,
                                    loc: utils_1.getRegexpLocation(sourceCode, node, csNode),
                                    messageId: "unexpected",
                                    data: {
                                        expr: ".",
                                    },
                                    fix(fixer) {
                                        return fix(fixer, node, csNode);
                                    },
                                });
                            }
                        }
                        return;
                    }
                    if (characterClassData && !characterClassData.reported) {
                        const key = getCharacterSetKey(csNode);
                        const alreadyCharSet = characterClassData.charSets.get(key);
                        if (alreadyCharSet != null &&
                            alreadyCharSet.negate === !csNode.negate) {
                            const ccNode = characterClassData.node;
                            if (!ccNode.negate &&
                                ccNode.elements.length === 2 &&
                                alreadyCharSet.kind === "space") {
                                if (!alreadyCharSet.negate) {
                                    if (allows.has(OPTION_SS1)) {
                                        return;
                                    }
                                }
                                else {
                                    if (allows.has(OPTION_SS2)) {
                                        return;
                                    }
                                }
                            }
                            context.report({
                                node,
                                loc: utils_1.getRegexpLocation(sourceCode, node, ccNode),
                                messageId: "unexpected",
                                data: {
                                    expr: ccNode.raw,
                                },
                                fix(fixer) {
                                    return fix(fixer, node, ccNode);
                                },
                            });
                            characterClassData.reported = true;
                        }
                        else {
                            characterClassData.charSets.set(key, csNode);
                        }
                    }
                },
                onCharacterClassRangeEnter(ccrNode) {
                    if (ccrNode.min.value === 0 &&
                        ccrNode.max.value === 65535) {
                        if (characterClassData &&
                            !characterClassData.reported) {
                            const ccNode = characterClassData.node;
                            context.report({
                                node,
                                loc: utils_1.getRegexpLocation(sourceCode, node, ccNode),
                                messageId: "unexpected",
                                data: {
                                    expr: ccNode.raw,
                                },
                                fix(fixer) {
                                    return fix(fixer, node, ccNode);
                                },
                            });
                            characterClassData.reported = true;
                        }
                    }
                },
                onCharacterClassEnter(ccNode) {
                    if (ccNode.elements.length === 0) {
                        if (ccNode.negate && !allows.has(OPTION_CARET)) {
                            context.report({
                                node,
                                loc: utils_1.getRegexpLocation(sourceCode, node, ccNode),
                                messageId: "unexpected",
                                data: {
                                    expr: "[^]",
                                },
                                fix(fixer) {
                                    return fix(fixer, node, ccNode);
                                },
                            });
                        }
                        return;
                    }
                    characterClassData = {
                        node: ccNode,
                        charSets: new Map(),
                        reported: false,
                    };
                },
                onCharacterClassLeave() {
                    characterClassData = null;
                },
            };
        }
        return utils_1.defineRegexpVisitor(context, {
            createVisitor,
        });
    },
});
