"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils");
function isCharacterInCharacterClassRange(char, range) {
    return range.min.value <= char.value && char.value <= range.max.value;
}
function isCharacterInCharacterSet(char, set) {
    if (set.kind === "digit") {
        return set.negate ? !utils_1.isDigit(char.value) : utils_1.isDigit(char.value);
    }
    if (set.kind === "space") {
        return set.negate ? !utils_1.isSpace(char.value) : utils_1.isSpace(char.value);
    }
    if (set.kind === "word") {
        return set.negate ? !utils_1.isWord(char.value) : utils_1.isWord(char.value);
    }
    return false;
}
function getRangesIntersection(a, b) {
    if (b[1] < a[0] || a[1] < b[0]) {
        return null;
    }
    return [Math.max(a[0], b[0]), Math.min(a[1], b[1])];
}
function getCharacterClassRangesIntersection(a, b) {
    return getRangesIntersection([a.min.value, a.max.value], [b.min.value, b.max.value]);
}
function getCharacterClassRangeAndCharacterSetIntersections(range, set) {
    if (set.negate) {
        return [];
    }
    const codePointRange = [range.min.value, range.max.value];
    function isCodePointIsRangeEdge(codePoint) {
        return (codePointRange[0] === codePoint || codePointRange[1] === codePoint);
    }
    function getIntersectionAndNotSeparate(otherRange) {
        const intersection = getRangesIntersection(codePointRange, otherRange);
        if (intersection) {
            if (codePointRange[0] < intersection[0] &&
                intersection[1] < codePointRange[1]) {
                return null;
            }
        }
        return intersection;
    }
    if (set.kind === "digit") {
        const intersection = getRangesIntersection(codePointRange, utils_1.CP_RANGE_DIGIT);
        return intersection ? [intersection] : [];
    }
    if (set.kind === "space") {
        const result = [];
        for (const codePoint of utils_1.CPS_SINGLE_SPACES) {
            if (isCodePointIsRangeEdge(codePoint)) {
                result.push(codePoint);
            }
        }
        const intersection = getIntersectionAndNotSeparate(utils_1.CP_RANGE_SPACES);
        return intersection ? [...result, intersection] : result;
    }
    if (set.kind === "word") {
        const intersections = [];
        for (const wordRange of utils_1.CP_RANGES_WORDS) {
            const intersection = getIntersectionAndNotSeparate(wordRange);
            if (intersection) {
                intersections.push(intersection);
            }
        }
        return isCodePointIsRangeEdge(utils_1.CP_LOW_LINE)
            ? [...intersections, utils_1.CP_LOW_LINE]
            : intersections;
    }
    return [];
}
function groupingElements(elements) {
    const characters = new Map();
    const characterClassRanges = new Map();
    const characterSets = new Map();
    for (const e of elements) {
        if (e.type === "Character") {
            const codePoint = e.value;
            const list = characters.get(codePoint);
            if (list) {
                list.push(e);
            }
            else {
                characters.set(codePoint, [e]);
            }
        }
        else if (e.type === "CharacterClassRange") {
            const key = String.fromCodePoint(e.min.value, e.max.value);
            const list = characterClassRanges.get(key);
            if (list) {
                list.push(e);
            }
            else {
                characterClassRanges.set(key, [e]);
            }
        }
        else if (e.type === "CharacterSet") {
            const key = buildCharacterSetKey(e);
            const list = characterSets.get(key);
            if (list) {
                list.push(e);
            }
            else {
                characterSets.set(key, [e]);
            }
        }
    }
    return {
        characters,
        characterClassRanges,
        characterSets,
    };
    function buildCharacterSetKey(characterSet) {
        if (characterSet.kind === "digit") {
            return characterSet.negate ? "D" : "d";
        }
        if (characterSet.kind === "space") {
            return characterSet.negate ? "S" : "s";
        }
        if (characterSet.kind === "word") {
            return characterSet.negate ? "W" : "w";
        }
        if (characterSet.kind === "property") {
            return `${`${characterSet.negate ? "P" : "p"}{${characterSet.value != null
                ? `${characterSet.key}=${characterSet.value}`
                : characterSet.key}`}}`;
        }
        return Symbol("unknown CharacterSet");
    }
}
exports.default = utils_1.createRule("no-dupe-characters-character-class", {
    meta: {
        type: "suggestion",
        docs: {
            description: "disallow duplicate characters in the RegExp character class",
            recommended: true,
        },
        schema: [],
        messages: {
            duplicates: 'Unexpected element "{{element}}" duplication.',
            charIsIncluded: 'The "{{char}}" is included in "{{element}}".',
            intersect: 'Unexpected intersection of "{{elementA}}" and "{{elementB}}" was found "{{intersection}}".',
        },
    },
    create(context) {
        const sourceCode = context.getSourceCode();
        function reportDuplicates(node, elements) {
            for (const element of elements) {
                context.report({
                    node,
                    loc: utils_1.getRegexpLocation(sourceCode, node, element),
                    messageId: "duplicates",
                    data: {
                        element: element.raw,
                    },
                });
            }
        }
        function reportCharIncluded(node, characters, element) {
            for (const char of characters) {
                context.report({
                    node,
                    loc: utils_1.getRegexpLocation(sourceCode, node, char),
                    messageId: "charIsIncluded",
                    data: {
                        char: char.raw,
                        element: element.raw,
                    },
                });
            }
        }
        function reportIntersect(node, elements, intersectElement, intersection) {
            const intersectionText = typeof intersection === "number"
                ? utils_1.invisibleEscape(intersection)
                : intersection[0] === intersection[1]
                    ? utils_1.invisibleEscape(intersection[0])
                    : `${utils_1.invisibleEscape(intersection[0])}-${utils_1.invisibleEscape(intersection[1])}`;
            for (const element of elements) {
                context.report({
                    node,
                    loc: utils_1.getRegexpLocation(sourceCode, node, element),
                    messageId: "intersect",
                    data: {
                        elementA: element.raw,
                        elementB: intersectElement.raw,
                        intersection: intersectionText,
                    },
                });
            }
        }
        function createVisitor(node) {
            return {
                onCharacterClassEnter(ccNode) {
                    const { characters, characterClassRanges, characterSets, } = groupingElements(ccNode.elements);
                    for (const [char, ...dupeChars] of characters.values()) {
                        if (dupeChars.length) {
                            reportDuplicates(node, [char, ...dupeChars]);
                        }
                        for (const [range] of characterClassRanges.values()) {
                            if (isCharacterInCharacterClassRange(char, range)) {
                                reportCharIncluded(node, [char, ...dupeChars], range);
                            }
                        }
                        for (const [set] of characterSets.values()) {
                            if (isCharacterInCharacterSet(char, set)) {
                                reportCharIncluded(node, [char, ...dupeChars], set);
                            }
                        }
                    }
                    for (const [key, [range, ...dupeRanges],] of characterClassRanges) {
                        if (dupeRanges.length) {
                            reportDuplicates(node, [range, ...dupeRanges]);
                        }
                        for (const [keyOther, [rangeOther],] of characterClassRanges) {
                            if (keyOther === key) {
                                continue;
                            }
                            const intersection = getCharacterClassRangesIntersection(range, rangeOther);
                            if (intersection) {
                                reportIntersect(node, [range, ...dupeRanges], rangeOther, intersection);
                            }
                        }
                        for (const [set] of characterSets.values()) {
                            const intersections = getCharacterClassRangeAndCharacterSetIntersections(range, set);
                            for (const intersection of intersections) {
                                reportIntersect(node, [range, ...dupeRanges], set, intersection);
                            }
                        }
                    }
                    for (const [set, ...dupeSets] of characterSets.values()) {
                        if (dupeSets.length) {
                            reportDuplicates(node, [set, ...dupeSets]);
                        }
                    }
                },
            };
        }
        return utils_1.defineRegexpVisitor(context, {
            createVisitor,
        });
    },
});
