"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const utils_1 = require("../utils");
function getPathToRoot(node) {
    const path = [];
    let current = node;
    while (current) {
        path.push(current);
        if (!current.parent) {
            break;
        }
        current = current.parent;
    }
    return path;
}
function isLookaround(node) {
    return (node.type === "Assertion" &&
        (node.kind === "lookahead" || node.kind === "lookbehind"));
}
function isNegativeLookaround(node) {
    return isLookaround(node) && node.negate;
}
function last(arr) {
    return arr[arr.length - 1];
}
exports.default = utils_1.createRule("no-useless-backreference", {
    meta: {
        docs: {
            description: "disallow useless backreferences in regular expressions",
            recommended: false,
        },
        schema: [],
        messages: {
            nested: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' from within that group.",
            forward: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears later in the pattern.",
            backward: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which appears before in the same lookbehind.",
            disjunctive: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in another alternative.",
            intoNegativeLookaround: "Backreference '{{ bref }}' will be ignored. It references group '{{ group }}' which is in a negative lookaround.",
        },
        type: "suggestion",
    },
    create(context) {
        function createVisitor(node) {
            return {
                onBackreferenceEnter(bref) {
                    const group = bref.resolved, brefPath = getPathToRoot(bref), groupPath = getPathToRoot(group);
                    let messageId = null;
                    if (brefPath.includes(group)) {
                        messageId = "nested";
                    }
                    else {
                        let i = brefPath.length - 1, j = groupPath.length - 1;
                        do {
                            i--;
                            j--;
                        } while (brefPath[i] === groupPath[j]);
                        const indexOfLowestCommonAncestor = j + 1, groupCut = groupPath.slice(0, indexOfLowestCommonAncestor), commonPath = groupPath.slice(indexOfLowestCommonAncestor), lowestCommonLookaround = commonPath.find(isLookaround), isMatchingBackward = lowestCommonLookaround &&
                            lowestCommonLookaround.kind === "lookbehind";
                        if (!isMatchingBackward && bref.end <= group.start) {
                            messageId = "forward";
                        }
                        else if (isMatchingBackward &&
                            group.end <= bref.start) {
                            messageId = "backward";
                        }
                        else if (last(groupCut).type === "Alternative") {
                            messageId = "disjunctive";
                        }
                        else if (groupCut.some(isNegativeLookaround)) {
                            messageId = "intoNegativeLookaround";
                        }
                    }
                    if (messageId) {
                        context.report({
                            node,
                            messageId,
                            data: {
                                bref: bref.raw,
                                group: group.raw,
                            },
                        });
                    }
                },
            };
        }
        return utils_1.defineRegexpVisitor(context, {
            createVisitor,
        });
    },
});
